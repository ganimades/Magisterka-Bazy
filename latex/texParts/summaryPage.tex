\section{Podsumowanie}

Celem pracy było porównanie wydajności oraz sposobów implementacji baz danych w~systemie iOS. Wykonane testy, przedstawione w~pracy pozwoliły porównać wydajność opisanych  baz danych. W~pracy przedstawione i~opisane zostały też fragmenty kodu dla każdej bazy danych potrzebne do wykonywania tych samych operacji. Przytoczone fragmenty kodu obrazują też różnice w~skomplikowaniu i~ilości potrzebnego kody do przeprowadzania tych samych zadań. 

Stworzono aplikacje na system iOS, która pozwala na wybranie bazy danych do testu, wykonanie odpowiednich testów, określenie ilości powtórzeń danego testu a~także wysłanie wyniku w~formacie CSV na adres email. 

Wykonano 10 różnych testów. Każdy z~testów został przeprowadzony na trzech zestawach danych: małym - 10-elementowym, średnim - 100-elementowym i~dużym - 1000-elementowym. Dodatkowo każdy z~testów dla uzyskania wiarygodnych wyników został wykonany sto razy. W~pracy testom zostały podane różne typy baz danych dlatego wynikiem końcowym każdego z~testów był moment otrzymania identycznych obiektów, które zostały uprzednio poddane zapisowi w~bazie. 

Podczas zapisu danych dominuje Domyślna Baza Użytkownika lecz należy pamiętać o~jej ograniczeniach takich jak brak relacji czy brak możliwości zapisu zdjęć. Baza Realm w~testach zapisu zajmuje drugie miejsce pod względem uzyskanych czasów, czas zapisu nie rośnie znacząco podczas zwiększania ilości zapisywanych danych. Core Data znacząco Zwiększa czas wraz ze wzrostem ilości danych. Najwolniejsze podczas zapisu danych okazały się bazy SQLite i~FMDB co pozwala stwierdzić, że zapis danych nie jest ich mocną stroną. 

Testy odczytu wszystkich danych pokazują, że zależnie od ilości danych testowane bazy osiągają różne czasy wykonania operacji. Realm pomimo przedostatniego rezultatu przy małej ilości rekordów zwiększa czas odczytu nieznacznie wraz z~ilością danych. Domyślna Baza Użytkownika radzi sobie dobrze jedynie z~małą ilością danych. Core Data osiąga najmniejszy czas podczas pracy ze średnim zestawem danych. Bazy SQLite i~FMDB osiągają najgorsze rezultaty ze wszystkich testowanych baz danych. 

Testy odczytu wybranych danych, które wymagały przeszukania zbioru jednoznacznie pokazują, że w~takich operacjach najlepiej spisuję się baza SQLite. FMDB wykorzystująca SQLite posiada większe czasy wykonywania operacji. Rezultaty Domyślnej Bazy Użytkownika zależne są od stopnia skomplikowania operacji, im bardziej złożona operacja tym czas wykonania zadania jest większy. Core Data i~Realm w~tego typu testach wypada różnie, wpływ na wyniki ma ilość danych i~stopień trudności operacji.

 W~testach usuwania wszystkich danych dominuje Domyślna Baza Użytkownika i~Realm. Core Data posiada trzeci co do wielkości czas usunięcia małej i~średniej ilości danych. Całkowite czyszczenie bazy najwięcej trwa w~przypadku SQLite i~FMDB.  Testy wymagające przeszukania bazy i~usunięciu jedynie wybranych elementów pokazują, że im bardziej skomplikowana jest operacja tym lepsze są bazy SQLite i~FMDB. W~przeciwnym wypadku Realm i~Domyślna Baza Użytkownika uzyskują lepsze rezultaty. Najwolniej tego typu operacje przeprowadzane są przez Core Data. 

Edycje danych najwolniej wykonuje Domyślna Baza Użytkownika i~Core Data. Doskonale zaś radzą sobie bazy SQL a~także Realm, który najlepiej spisuję się podczas edycji całych tabel. 

Przytoczone fragmenty kodu obrazują sposoby i~różnice implementacji użytych w~pracy baz danych. Najmniejszy nakład pracy programisty wymagany jest podczas używania bazy Realm. Dostarcza ona doskonały interfejs dzięki, któremu nawet skomplikowane operacje programista jest w~stanie zaimplementować za pomocą jedynie kilku linii kodu. Core Data wymaga doskonałej znajomości tego narzędzia, nakład kodu jest większy niż w~przypadku Realm. SQLite posiada nieczytelny interfejs a~także wymaga bardzo dobrej znajomości baz SQL. Operację są trudne w~zaimplementowaniu. Opisane problemy bazy SQLite eliminuje biblioteka opakowująca FMDB niestety wnosi ona opóźnienia przez, które wypada ona gorzej pod względem wydajności. Domyślna Baza Użytkownika wymaga jedynie znajomości języka programowania lecz implementacja skomplikowanych operacji jest bardzo skomplikowana i~wymaga dużej ilości kodu. 

Wskazanie najbardziej wydajnej bazy danych jest bardzo trudne. Uzależnione jest to od wielu czynników między innymi: ilości przechowywanych danych, rodzaju najczęściej wykonywanych operacji przez bazę czy też typu przechowywanych danych. Wydajność każdej z~bazy może też ulec zmianie poprzez wykorzystanie różnego typu dostępnych bibliotek do operacji na zmiennych. Tego typu biblioteki mogą znacząco poprawić wydajność baz SQL poprzez szybszą konwersje typów zmiennych przechowywanych w~obiektach programu pomiędzy typami wymaganymi do zapisu w~bazie. Jednoznacznie można zaś stwierdzić iż najprostszy interfejs i~sposób implementacji posiada biblioteka Realm.